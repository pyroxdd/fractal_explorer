//generated with fths (find in cmake)
unsigned char fragment[] = 
"#version 300 es\n"
"precision mediump float;\n"
"out vec4 fragcolor;\n"
"uniform vec2 u_resolution;\n"
"uniform float u_zoom;  // Zoom level (e.g., 1.0 for normal, 100.0 for deep zoom)\n"
"uniform vec2 u_offset; // Offset for panning\n"
"uniform int u_max_iter;\n"
"uniform float u_time;\n"
"\n"
"void main() {\n"
"    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / u_resolution.y;\n"
"    vec2 c = uv / u_zoom + u_offset;  // Adjust based on zoom and offset\n"
"    vec2 z = vec2(0.0);\n"
"\n"
"    // int maxIter = int(50.0 + log(u_zoom) * 20.0); // Dynamic iterations\n"
"\n"
"    int i;\n"
"    for (i = 0; i < u_max_iter; i++) {\n"
"        // if (dot(z, z) > 4.0) break;\n"
"        if (dot(z, z) > 16.0) break;\n"
"        // z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n"
"        z = vec2(z.x * z.x - z.y * z.y, (2.0 + sin(u_time)) * z.x * z.y) + c;\n"
"    }\n"
"\n"
"    float t = float(i) / float(u_max_iter);\n"
"    \n"
"    // fragcolor = vec4(t, t * t, t * t * t, 1.0);\n"
"    // if (t >= 0.99) fragcolor = vec4(1.0, 1.0, 1.0, 1.0);\n"
"    // else fragcolor = vec4(0.0, 0.0, 0.0, 1.0);\n"
"    if (i % 2 == 0) fragcolor = vec4(1.0, 1.0, 1.0, 1.0);\n"
"    else fragcolor = vec4(0.0, 0.0, 0.0, 1.0);\n"
"}\n"
"\n"
"\n"
"// #version 300 es\n"
"// precision highp float;\n"
"// out vec4 fragcolor;\n"
"\n"
"// uniform highp vec2 u_resolution;\n"
"// uniform highp float u_zoom;\n"
"// uniform highp vec2 u_offset;\n"
"// uniform int u_maxIter; // For deep zooms, try increasing this beyond 1000\n"
"\n"
"// ////////////////////////\n"
"// // Double-double arithmetic helper functions\n"
"\n"
"// // Split a float into high and low parts\n"
"// vec2 splitFloat(float a) {\n"
"//     float c = 4097.0 * a; // (2^12 + 1)\n"
"//     float a_hi = c - (c - a);\n"
"//     float a_lo = a - a_hi;\n"
"//     return vec2(a_hi, a_lo);\n"
"// }\n"
"\n"
"// // Two-product: returns product and error term as a double-double\n"
"// vec2 twoProd(float a, float b) {\n"
"//     float p = a * b;\n"
"//     vec2 a_split = splitFloat(a);\n"
"//     vec2 b_split = splitFloat(b);\n"
"//     float err = a_split.y * b_split.y -\n"
"//                 (((p - a_split.x * b_split.x) - a_split.y * b_split.x) - a_split.x * b_split.y);\n"
"//     return vec2(p, err);\n"
"// }\n"
"\n"
"// // Two-sum: returns sum and error term as a double-double\n"
"// vec2 twoSum(float a, float b) {\n"
"//     float s = a + b;\n"
"//     float bp = s - a;\n"
"//     float err = (a - (s - bp)) + (b - bp);\n"
"//     return vec2(s, err);\n"
"// }\n"
"\n"
"// // Add two double-doubles (each stored in a vec2: (hi, lo))\n"
"// vec2 dd_add(vec2 a, vec2 b) {\n"
"//     vec2 s = twoSum(a.x, b.x);\n"
"//     float err = a.y + b.y + s.y;\n"
"//     vec2 r = twoSum(s.x, err);\n"
"//     return r;\n"
"// }\n"
"\n"
"// // Subtract two double-doubles: a - b\n"
"// vec2 dd_sub(vec2 a, vec2 b) {\n"
"//     vec2 s = twoSum(a.x, -b.x);\n"
"//     float err = a.y - b.y + s.y;\n"
"//     vec2 r = twoSum(s.x, err);\n"
"//     return r;\n"
"// }\n"
"\n"
"// // Multiply two double-doubles: a * b\n"
"// vec2 dd_mul(vec2 a, vec2 b) {\n"
"//     vec2 p = twoProd(a.x, b.x);\n"
"//     float err = a.x * b.y + a.y * b.x;\n"
"//     vec2 s = twoSum(p.x, err);\n"
"//     return vec2(s.x, s.y + p.y);\n"
"// }\n"
"\n"
"// // Convert a float to a double-double (with zero error part)\n"
"// vec2 to_dd(float a) {\n"
"//     return vec2(a, 0.0);\n"
"// }\n"
"\n"
"// ////////////////////////\n"
"// // Complex number in double-double arithmetic\n"
"// struct dcomplex {\n"
"//     vec2 re; // Real part as a double-double (hi, lo)\n"
"//     vec2 im; // Imaginary part as a double-double (hi, lo)\n"
"// };\n"
"\n"
"// // Complex addition: a + b\n"
"// dcomplex dc_add(dcomplex a, dcomplex b) {\n"
"//     dcomplex r;\n"
"//     r.re = dd_add(a.re, b.re);\n"
"//     r.im = dd_add(a.im, b.im);\n"
"//     return r;\n"
"// }\n"
"\n"
"// // Complex multiplication: a * b\n"
"// dcomplex dc_mul(dcomplex a, dcomplex b) {\n"
"//     dcomplex r;\n"
"//     // r.re = a.re * b.re - a.im * b.im\n"
"//     r.re = dd_sub(dd_mul(a.re, b.re), dd_mul(a.im, b.im));\n"
"//     // r.im = a.re * b.im + a.im * b.re\n"
"//     r.im = dd_add(dd_mul(a.re, b.im), dd_mul(a.im, b.re));\n"
"//     return r;\n"
"// }\n"
"\n"
"// // Complex square: a^2\n"
"// dcomplex dc_sqr(dcomplex a) {\n"
"//     return dc_mul(a, a);\n"
"// }\n"
"\n"
"// // Compute magnitude squared of a complex number: |a|^2 = a.re^2 + a.im^2\n"
"// vec2 dc_mag2(dcomplex a) {\n"
"//     vec2 re2 = dd_mul(a.re, a.re);\n"
"//     vec2 im2 = dd_mul(a.im, a.im);\n"
"//     return dd_add(re2, im2);\n"
"// }\n"
"\n"
"// ////////////////////////\n"
"// // Mandelbrot iteration using double-double arithmetic\n"
"// float mandelbrot(dcomplex c, int maxIter) {\n"
"//     dcomplex z;\n"
"//     z.re = to_dd(0.0);\n"
"//     z.im = to_dd(0.0);\n"
"//     int i;\n"
"//     for (i = 0; i < maxIter; i++) {\n"
"//         vec2 mag2 = dc_mag2(z);\n"
"//         if (mag2.x > 4.0) break;\n"
"//         z = dc_add(dc_sqr(z), c);\n"
"//     }\n"
"//     return float(i);\n"
"// }\n"
"\n"
"// ////////////////////////\n"
"// // Simple color mapping function\n"
"// vec3 getColor(float iter, float maxIter) {\n"
"//     float t = iter / maxIter;\n"
"//     return vec3(t, t*t, t*t*t);\n"
"// }\n"
"\n"
"// ////////////////////////\n"
"// // Main shader entry\n"
"// void main() {\n"
"//     // First, compute normalized screen coordinates using gl_FragCoord.\n"
"//     // We'll convert these to double-double numbers.\n"
"//     float normX = (gl_FragCoord.x - 0.5 * u_resolution.x) / u_resolution.y;\n"
"//     float normY = (gl_FragCoord.y - 0.5 * u_resolution.y) / u_resolution.y;\n"
"    \n"
"//     // Convert normalized coordinates into double-double format.\n"
"//     vec2 dd_normX = to_dd(normX);\n"
"//     vec2 dd_normY = to_dd(normY);\n"
"    \n"
"//     // Create a dcomplex for the uv coordinate.\n"
"//     dcomplex uv_dd;\n"
"//     uv_dd.re = dd_normX;\n"
"//     uv_dd.im = dd_normY;\n"
"    \n"
"//     // Instead of computing (uv / u_zoom) in float, compute it using double-double.\n"
"//     // We compute the reciprocal of u_zoom in float and convert it.\n"
"//     float invZoom = 1.0 / u_zoom;\n"
"//     vec2 dd_invZoom = to_dd(invZoom);\n"
"    \n"
"//     // Scale the uv coordinate by dd_invZoom.\n"
"//     vec2 c_re_dd = dd_mul(uv_dd.re, dd_invZoom);\n"
"//     vec2 c_im_dd = dd_mul(uv_dd.im, dd_invZoom);\n"
"    \n"
"//     // Add the offset (converted to double-double) to get the final complex coordinate c.\n"
"//     dcomplex c;\n"
"//     c.re = dd_add(c_re_dd, to_dd(u_offset.x));\n"
"//     c.im = dd_add(c_im_dd, to_dd(u_offset.y));\n"
"    \n"
"//     // Run the Mandelbrot iteration using double-double arithmetic.\n"
"//     float iter = mandelbrot(c, u_maxIter);\n"
"    \n"
"//     // Map iteration count to color.\n"
"//     vec3 color = getColor(iter, float(u_maxIter));\n"
"//     fragcolor = vec4(color, 1.0);\n"
"// }\n"
"";